<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,700;1,400&family=Kanit:wght@700&display=swap');
    </style>
    <link
            rel="stylesheet"
            href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css"
            integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2"
            crossorigin="anonymous"
    />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js" defer></script>
    <link rel="stylesheet" href="../public/assets/style_documentation.css" />

    <title>Happy Blog Documentation</title>
</head>

<body>

<div class="container-md">
    <div class="row item">
        <div class="col-6 text">
            <p>
                When accessing the website – your own personal blog – the first thing you see is the welcome page.
                There you are greeted with a message and a button that would bring you to an overview of all your blog
                entries. But there is also an index to the left from where you could go to particular blog entries
                directly. Above all that is a bar containing your blog’s name and buttons for editing and adding blog
                entries as well as the button that brought you here – to the documentation of the website.
                While there was still no particular article selected the edit button will not respond whereas the add
                entry button can be called from any point in the website.
                On the right you can see the chat which will be explained in detail later.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/docu_welcome.png">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                After pressing the “show entries” button you get to the homepage – a place where all your public
                entries are listed chronologically. You get to read their title and short description. If you want to
                read further into a certain entry there is a button for each one that brings you to the whole text.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                Once you chose an entry to read more about you will reach this screen. In addition to the information
                you get from the homepage you can also see the full text of the article as well as any pictures that
                may be uploaded. Underneath the title you have two buttons – one for getting back to the homepage and
                one for deleting the current entry. Now the edit button will also be activated so you can edit the
                entry you’re just reading. You may also have noticed that the index popped open to facilitate reading
                through the blog without the need to get back to the homepage every time.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/docu_entry.png">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                This is the index. You can reach it from every page of your blog by just clicking on it. It separates
                the articles into public (left) and private (right) entries which can be reached through the according
                button on top of the entry list. If you chose an article from this list you will reach the same page
                you’re just seeing for the article selected.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/docu_index.png">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                Here you can see the main view when editing an entry. Everything that was there before will be
                automatically added to the corresponding field so you don’t have to rewrite the whole article.
                Underneath you can find the option to upload images. You can either select them by browsing through
                your files or you can just drag & drop them. After uploading you can see them added to the file list
                where you also have the option to delete the uploaded files. You also have the option to draw images
                on your own. On the bottom you can see buttons to save your changes or to cancel the editing process.
                This view will also be presented when you choose to add a new entry. Everything is the same except
                that all fields will be empty.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/docu_editentry.png">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                Here you can see what it looks like when you write something in the chat. Before you can do that
                though you are asked to choose a username which will stay the same while you’re on the blog. After
                that you can write messages and everybody that is currently on your blog will receive them. And even
                users who join later will receive the last 20 messages that were in the chat. Other users can also
                participate in the chat the same way that you can.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/docu_chat.png">
        </div>

    </div>
    <div class="row item">
        <div class="col-6 text">
            <header>
            <h2>Canvas</h2>
            <p>
                For our graphics technology we decided to use canvas. This is part of the CanvasController.js file, which
                gets all the elements associated with the canvas by id and initialises them.
                A canvasView object is also initialised. The CanvasController listens for events and then calls for the
                corresponding functions of canvasView.
            </p>
            </header>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/canvasController.PNG">
        </div>
    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                In canvasView we start off by getting the canvas element itself from the
                contentBoxView.js innerHTML. We define all the necessary variables and the basic size
                of the canvas itself. All the elements in the canvas are also pulled from the innerHTML.
                drawLine is the function that draws the strokes and applies thickness, color and style to it.

            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/canvasView1.PNG">
        </div>
    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                Here are a few more functions regarding disabling the Undo and Redo buttons as long as there have been
                no strokes to undo/redo. clearCanvas deletes all of the strokes and disables the buttons.
                The following two functions react to mouseEvents, for example canvasOnMouseDown gets the starting
                position of the stroke and canvasOnMouseMove follows the mouse pointer and draws a line in its path.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/canvasView2.PNG">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                canvasOnMouseUp ends the stroke and stores it in the undoArray in case it has to
                be deleted in the future. thicknessOnChange assigns a value picked by the user from the
                thickness slider and assigns it to the stroke. clearButtonOnClick is what happens when
                the user clicks the delete button. An alert pops up and depending on the user's
                choice the clearCanvas function gets called.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/canvasView3.PNG">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                undoButtonOnClick is the function that keeps track of the number of
                strokes and stores them in an array to undo them based on the user's input.
                redoButtonOnClick does almost the same but with a different array which - upon redo -
                gets the latest undone stroke from the undo array if the user presses Redo.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/canvasView4.PNG">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                saveButtonOnClick is the function that converts all of the strokes into a base64 string
                which enables the user to download their drawing and add it to their entry. It does this using the
                HTMLCanvasElement.toDataURL() method which returns a data URL containing a representation of the image
                in the format specified by the type parameter (defaults to PNG).
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/canvasView5.PNG">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <h2>Model, View and Controller</h2>
            <h3>Controller</h3>
            <p>
                The Controller file takes care of all the communication with the Server.
                All eventListener functions are in the Controller.js file and are waiting on
                user input to call corresponding functions in Views.js and Models.js.
                We use XMLHttpRequests to issue HTTP requests in order to exchange data
                between the web site and the server. To send an HTTP request, we create an XMLHttpRequest object, open a URL, and send the request.
                The "POST" and "GET" methods are part of our router in entries.js.
                After the transaction completes, the object will contain the information we need. We do this
                primarily for our form data.

            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/controller.PNG">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                handleResetRequest0 uses the history which gives us the ability to
                modify a website's URL without a full page refresh. This is necessary for a single page application like ours
                and is useful for loading portions of a page with JavaScript and if the content is different enough to warrant
                a new URL like for example the Add Entry page.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/controller2.PNG">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                The following functions call the corresponding views.js functions and get
                the required data by calling the required models.js functions. This is also where
                you start to see our usage of slug which is a clearer way of retrieving
                items and it ends up showing the title of the current entry in the URL.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/controller3.PNG">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                handleUploadListChanged works together with the file input HTML
                element to add a list of files added for upload to the nameList element
                in our Add Entry page. This happens either automatically through the
                input="file" "Browse" context menu or through the means of drag and drop.
                In registerEventListenerById we add the ability to add specific eventlisteners
                to views, controller models if we need them.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/controller4.PNG">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <h3>Views</h3>
            <p>
                In our Views file we have all the functions that make changes to the
                HTML and innerHTML and take care of the appearance of all of the different
                pages. We also instantiated two extra Controller files in order to be able to
                use their functions to load the corresponding features. In handleIndexRequest
                we check if we have gotten an entry as this is also the functions parameter
                and parse it in order to be able to use the showIndex function which writes all
                our entries into the index bar.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/views.PNG">
        </div>
    </div>

    <div class="row item">
        <div class="col-6 text">
            <h3>dragDropView</h3>
            <p>
                This file contains the handleDrop function which gets called through the
                DragDropController and handles what happens to a file when it gets dropped into
                the "dropzone" element. First we initialise a fileInput file which we add our
                files into using dataTransfer. This skips the need to open the Browse context menu
                of the input="file" element and this allows us to temporarily store files which will
                later be uploaded upon pressing the Save button. This function also updates the
                list visible to the user.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/draganddrop.PNG">
        </div>
    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                Upon clicking of the Show Entries button on the welcome screen all
                current public entries are listed. As can be seen in the handleEditButton
                function we use sessionStorage here to temporarily save any changes a user might
                make to an entry upon clicking the Edit button. The page itself gets updated
                to the Edit Page using ContentBoxView.showEditEntry. All of our innerHTML is contained
                in the contentBoxView.js file. This is also one of the times we call the loadCanvas
                and loadDragDrop functions through the instantiated Controllers and their Views files.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/views2.PNG">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <h2>Server Side Storage - JSON, entry</h2>
            <p>
                Here we add all the dependencies, libraries and packages and define
                our Schema which the JSON objects will follow. Title, Description and
                Markdown are simple text fields that use String as their datatype, createdAt
                is our date, Date.now converts it to a more userf riendly format similar to the
                one the client's device uses. slug uses slugify to make a string of numbers and
                letters into something readable like for example the title of the entry which will
                be displayed in the URL. sanitizedHtml "sanitizes" the markdown to make it safer
                against malicious usage attempts to for example write HTML directly into our markdown
                field and use the server for something nefarious.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/entry.PNG">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                isPublic is a Boolean which is controlled through a checkbox and this
                decides whether or not the entry will be saved locally or to our database.
                images is an array of objects of a few different attributes/properties.
                This is what we use to save our images to the database. Our images get encoded to
                base64 which means we can use string as the main datatype for every attribute here.
                originalName is a property of our data transfer middleware multer and it gets the
                original name of the file before encoding. path is the path of the file and data is
                where our base64 string ends up being saved.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/entry2.PNG">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                On the server side the public entries are saved. This is done by help of the mongoose package for Node.js.
                An entry schema is defined to save all entries in the MongoDB database which runs locally.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/Documentation_Server_Model.PNG">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                On the client side localStorage is used to store private entries which can be only seen
                by the user of this specific computer. Also sessionStorage is used for temporary saving form data and form
                changes. The used keys for accessing the key-value pairs are shown in the picture next to this text.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/Documentation_Client_Model.PNG">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                In the Models object an API for accessing and saving entries and other important data is provided. This API
                is used in the Controller for easily saving and retrieving data from the webStorage.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/Documentation_Client_Model_2.PNG">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                After initializing the application server on port 5000 a WebSocket server is created and bond to that
                server. It is specified that on the establishment of a new connection the chatlog is send to new client.
                Logging a message takes places with a global server variable being an array of Strings. If this array
                has less than 20 entries the new message is just pushed to the end. If it has reached a size of 20 the
                first message of it is deleted and all other messages are shifted to make room in the 20th index for
                the new chat message. On reception of a new message the message is added to the log and forwarded to
                every other connected client.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/docu_websocketserver.png">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                In HTML the chat is represented as a column of size 2 using bootstrap. Inside this column there is the
                message box followed by a text area followed by a button. Depending on the state of the program either
                the message box and the send button are displayed or the username box and the confirm button. When
                accessing the website the first time the latter two are displayed.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/docu_websockethtmlk.png">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                On the client side the main part of the work is done by the WebSocket controller which is created the
                first time the page is loaded. At first all relevant HTML objects get retrieved to be manipulated
                later. Then this function is being called. At first it opens a connection to the server on the same
                port as the application is running. Then the behaviour for different states is defined. On opening
                there is just a log message. On reception of a message the data being transmitted is passed onto a
                function in the view component of the WebSocket to display it together with the information that the
                message to display is of external nature. On closing the variable for storing the WebSocket is reset.
                Then event listeners for the previously explained buttons are added. The confirm button simply stops
                displaying itself and the username box to make room for the send button and the new message box. The
                send button first checks if there is a WebSocket connection. If not this is shown inside the chat. If
                it is and the there is some actual text inside the new message box the message to display is composed
                of the username that was previously entered and the new message. This is then send via the WebSocket to
                the server and also send to the view component together with the information that this time the message
                is of internal nature.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/docu_websocketcontroller.png">
        </div>

    </div>

    <div class="row item">
        <div class="col-6 text">
            <p>
                The WebSocketView component is responsible for altering the content of the chat box upon new messages.
                At first the relevant HTML objects are retrieved. Then when a new message is created or received the
                showMessage function gets called. Depending on the origin of the message the alignment inside the box
                the background colour of the message and the border of the message are determined. Then the message
                gets wrapped in some HTML code to be added to the chat HTML object. Afterwards it is auto-scrolled to
                the bottom of the chat box and the content of the new message box is deleted.
            </p>
        </div>
        <div class="col-6 align-self-center">
            <img class="image" src="../public/resources/docu_websocketview.png">
        </div>

    </div>


    <hr>

</div>

</body>
</html>
